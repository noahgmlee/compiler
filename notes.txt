Virtual machine:
- Java, Python (java script?)
- VM does CPU/HW emulation
- byte code in -> VM -> programs behaviour
- some JIT mixed in too for just in time compilation

Runtime:
- service during program execution supporting:
    - garbage collection
    - type tracking
- VM needs the runtime executing in addition to the byte code interpretation
- a compiled language (Go) needs to compile with the runtime environment
- this means garbage collection and type tracking a part of the executable

Compiler vs Interpreter:
- compiler produces alternative form from source code - IR, another source file, machine code, byte code
    - it does not execute it
- interpreter executes when it is run, maybe it translates source code, but it also starts running it

Context free grammars:
- define the rules that the language must follow
- the rules in the books example are allowable substitions
    - sometimes substitutions also have their own allowable substitutions
    - eventually the substitions tree has a terminal point.

A good point on OOP vs functional for representing AST Expressions:
- OOP is nice to group implementations onto expression types (interpret, resolve and analyze) a Binary vs Unary Expression
    - should a new function be added it becomes tedious to maintain
- Functional allows a single function to handle "interpret" for all objects
    - should a new object (expression type) be added it becomes tedious to maintain

Parsing:
- we want deterministic handling of the:
    - derived expressions from the lexer (token stream)
    - tree representation of expressions
- operators must have a precedence and an associativity
- precedence is the relative importance (what must be evaluated before other operators)
- associativity is kind of like presedence relative to itself (left first or right first)
- precedence is achieved by defining each grammars allowable matching to include that which is one precedence level higher
    - this way all branches reach a terminal expression
    - Nystrom builds a recursive descent parser, so we CANNOT have left-recursive matching. this will create infinite loops
- recursive descent is really awesome! very easy to follow, clean impl