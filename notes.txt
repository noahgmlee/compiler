Virtual machine:
- Java, Python (java script?)
- VM does CPU/HW emulation
- byte code in -> VM -> programs behaviour
- some JIT mixed in too for just in time compilation

Runtime:
- service during program execution supporting:
    - garbage collection
    - type tracking
- VM needs the runtime executing in addition to the byte code interpretation
- a compiled language (Go) needs to compile with the runtime environment
- this means garbage collection and type tracking a part of the executable

Compiler vs Interpreter:
- compiler produces alternative form from source code - IR, another source file, machine code, byte code
    - it does not execute it
- interpreter executes when it is run, maybe it translates source code, but it also starts running it

Context free grammars:
- define the rules that the language must follow
- the rules in the books example are allowable substitions
    - sometimes substitutions also have their own allowable substitutions
    - eventually the substitions tree has a terminal point.

A good point on OOP vs functional for representing AST Expressions:
- OOP is nice to group implementations onto expression types (interpret, resolve and analyze) a Binary vs Unary Expression
    - should a new function be added it becomes tedious to maintain
- Functional allows a single function to handle "interpret" for all objects
    - should a new object (expression type) be added it becomes tedious to maintain